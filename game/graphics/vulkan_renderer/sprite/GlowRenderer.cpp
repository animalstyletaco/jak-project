#include "GlowRenderer.h"

#include "third-party/imgui/imgui.h"

/*
 * The glow renderer draws a sprite, but only if the center of the sprite is "visible".
 * To determine visibility, we draw a test "probe" at the center of the sprite and see how many
 * pixels of the probe were visible.
 *
 * The inputs to this renderer are the transformed vertices that would be computed on VU1.
 * The convention is that float -> int conversions and scalings are dropped.
 *
 * To detect if this is visible, we do something a little different from the original game:
 * - first copy the depth buffer to a separate texture. It seems like we could eliminate this copy
 *   eventually and always render to a texture.
 *
 * - For each sprite draw a "test probe" using this depth buffer. Write to a separate texture.
 *   This test probe is pretty small. First clear alpha to 0, then draw a test image with alpha = 1
 *   and depth testing on.
 *
 * - Repeatedly sample the result of the probe as a texture and draw it to another texture with half
 *   the size. This effectively averages the alpha values with texture filtering.
 *
 * - Stop once we've reached 2x2. At this point we can sample the center of this "texture" and the
 *   alpha will indicate the fraction of pixels in the original probe that passed depth. Use this
 *   to scale the intensity of the actual sprite draw.
 *
 * There are a number of optimizations made at this point:
 * - Probe clear/drawing are batched.
 * - Instead of doing the "downsampling" one-at-a-time, all probes are copied to a big grid and
 *   the downsampling happens in batches.
 * - The sampling of the final downsampled texture happens inside the vertex shader. On PS2, it's
 *   used as a texture, drawn as alpha-only over the entire region, then blended with the final
 *   draw. But the alpha of the entire first draw is constant, and we can figure it out in the
 *   vertex shader, so there's no need to do this approach.
 *
 * there are a few remaining improvements that could be made:
 *   - The final draws could be bucketed, this would reduce draw calls by a lot.
 *   - The depth buffer copy could likely be eliminated.
 *   - There's a possibility that overlapping probes do the "wrong" thing. This could be solved by
 *     copying from the depth buffer to the grid, then drawing probes on the grid. Currently the
 *     probes are drawn aligned with the framebuffer, then copied back to the grid. This approach
 *     would also lower the vram needed.
 */

GlowVulkanRenderer::GlowVulkanRenderer(std::unique_ptr<GraphicsDeviceVulkan>& device, VulkanInitializationInfo& vulkan_info) : m_device(device), m_vulkan_info(vulkan_info), m_pipeline_layout(device) {
  // dynamic buffer: this will hold vertices that are generated by the game and updated each frame.
  // the most important optimization here is to have as few uploads as possible. The size of the
  // upload isn't too important - we only have at most 256 sprites so the overhead of uploading
  // anything dominates. So we use a single vertex format for all of our draws.

  GraphicsPipelineLayout::defaultPipelineConfigInfo(m_pipeline_config_info);

  m_ogl.vertex_buffer = std::make_unique<VertexBuffer>(m_device, sizeof(Vertex), kMaxVertices, 1);
  m_ogl.index_buffer = std::make_unique<IndexBuffer>(m_device, sizeof(u32), kMaxVertices, 1);

  m_ogl_downsampler.vertex_buffer =
      std::make_unique<VertexBuffer>(m_device, sizeof(Vertex), m_downsample_vertices.size(), 1);
  m_ogl_downsampler.vertex_buffer->writeToGpuBuffer(m_downsample_vertices.data());

  m_ogl_downsampler.index_buffer =
      std::make_unique<IndexBuffer>(m_device, sizeof(u32), m_downsample_indices.size(), 1);
  m_ogl_downsampler.index_buffer->writeToGpuBuffer(m_downsample_indices.data());

  InitializeGlowDrawInputAttributes();
  InitializeGlowProbeInputAttributes();
  InitializeGlowProbeReadInputAttributes();
  InitializeGlowProbeReadDebugInputAttributes();
  InitializeGlowProbeDownsampleInputAttributes();

  //TODO: Figure out how to implement GL_DEPTH_COMPONENT24 in swap chain
  //m_ogl.probe_fbo = std::make_unique<SwapChain>(m_device, VkExtent2D{m_ogl.probe_fbo_w, m_ogl.probe_fbo_h});

  // downsample fbo setup: each will hold a grid of probes.
  // there's one fbo for each size.
  int ds_size = kFirstDownsampleSize;
  for (int i = 0; i < kDownsampleIterations; i++) {
    VkExtent3D extents = {ds_size * kDownsampleBatchWidth, ds_size * kDownsampleBatchWidth, 1};

    m_ogl.downsample_fbos[i].texture = std::make_unique<VulkanTexture>(m_device);
    m_ogl.downsample_fbos[i].texture->createImage(extents, 1, VK_IMAGE_TYPE_2D,
                                                  VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_LINEAR,
                                                  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT);

    m_ogl.downsample_fbos[i].texture->createImageView(VK_IMAGE_VIEW_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_ASPECT_COLOR_BIT, 1);
    
    ds_size /= 2;
  }
}

void GlowVulkanRenderer::InitializeGlowProbeInputAttributes() {
  auto& shader = m_vulkan_info.shaders[ShaderId::GLOW_PROBE];

  VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
  vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
  vertShaderStageInfo.module = shader.GetVertexShader();
  vertShaderStageInfo.pName = "main";

  VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
  fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
  fragShaderStageInfo.module = shader.GetFragmentShader();
  fragShaderStageInfo.pName = "main";

  m_glow_probe_vulkan_inputs.shaderStages = {vertShaderStageInfo, fragShaderStageInfo};

  VkVertexInputBindingDescription bindingDescription{};
  bindingDescription.binding = 0;
  bindingDescription.stride = sizeof(Vertex);
  bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
  m_glow_probe_vulkan_inputs.bindingDescriptions.push_back(bindingDescription);

  std::array<VkVertexInputAttributeDescription, 3> attributeDescriptions{};
  attributeDescriptions[0].binding = 0;
  attributeDescriptions[0].location = 0;
  attributeDescriptions[0].format =
      VK_FORMAT_R32G32B32A32_SFLOAT;  // Is there a way to normalize floats
  attributeDescriptions[0].offset = offsetof(Vertex, x);

  attributeDescriptions[1].binding = 0;
  attributeDescriptions[1].location = 1;
  attributeDescriptions[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
  attributeDescriptions[1].offset = offsetof(Vertex, r);

  m_glow_probe_vulkan_inputs.attributeDescriptions.insert(
      m_glow_probe_vulkan_inputs.attributeDescriptions.end(),
      attributeDescriptions.begin(), attributeDescriptions.end());
}

void GlowVulkanRenderer::InitializeGlowProbeReadInputAttributes() {
  auto& shader = m_vulkan_info.shaders[ShaderId::GLOW_PROBE_READ];

  VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
  vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
  vertShaderStageInfo.module = shader.GetVertexShader();
  vertShaderStageInfo.pName = "main";

  VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
  fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
  fragShaderStageInfo.module = shader.GetFragmentShader();
  fragShaderStageInfo.pName = "main";

  m_glow_probe_read_vulkan_inputs.shaderStages = {vertShaderStageInfo, fragShaderStageInfo};

  // static buffer: this will hold draws for downsampling. Because everything is normalized, we can
  // reuse the same vertices for all downsampling!
  // Note that we can't do a single giant square - otherwise it would "bleed" over the edges.
  // the boundary between cells needs to be preserved.
  VkVertexInputBindingDescription bindingDescription{};
  bindingDescription.binding = 0;
  bindingDescription.stride = sizeof(Vertex);
  bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
  m_glow_probe_read_vulkan_inputs.bindingDescriptions.push_back(bindingDescription);

  std::array<VkVertexInputAttributeDescription, 3> attributeDescriptions{};
  attributeDescriptions[0].binding = 0;
  attributeDescriptions[0].location = 0;
  attributeDescriptions[0].format =
      VK_FORMAT_R32G32B32A32_SFLOAT;  // Is there a way to normalize floats
  attributeDescriptions[0].offset = offsetof(Vertex, x);

  attributeDescriptions[1].binding = 0;
  attributeDescriptions[1].location = 1;
  attributeDescriptions[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
  attributeDescriptions[1].offset = offsetof(Vertex, r);

  // FIXME: Make sure format for byte and shorts are correct
  attributeDescriptions[2].binding = 0;
  attributeDescriptions[2].location = 2;
  attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
  attributeDescriptions[2].offset = offsetof(Vertex, u);

  m_glow_probe_read_vulkan_inputs.attributeDescriptions.insert(
      m_glow_probe_read_vulkan_inputs.attributeDescriptions.end(), attributeDescriptions.begin(),
      attributeDescriptions.end());
}

void GlowVulkanRenderer::InitializeGlowProbeReadDebugInputAttributes() {
  auto& shader = m_vulkan_info.shaders[ShaderId::GLOW_PROBE_READ_DEBUG];

  VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
  vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
  vertShaderStageInfo.module = shader.GetVertexShader();
  vertShaderStageInfo.pName = "main";

  VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
  fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
  fragShaderStageInfo.module = shader.GetFragmentShader();
  fragShaderStageInfo.pName = "main";

  m_glow_probe_read_debug_vulkan_inputs.shaderStages = {vertShaderStageInfo, fragShaderStageInfo};

  // static buffer: this will hold draws for downsampling. Because everything is normalized, we can
  // reuse the same vertices for all downsampling!
  // Note that we can't do a single giant square - otherwise it would "bleed" over the edges.
  // the boundary between cells needs to be preserved.
  VkVertexInputBindingDescription bindingDescription{};
  bindingDescription.binding = 0;
  bindingDescription.stride = sizeof(Vertex);
  bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
  m_glow_probe_read_debug_vulkan_inputs.bindingDescriptions.push_back(bindingDescription);

  std::array<VkVertexInputAttributeDescription, 3> attributeDescriptions{};
  attributeDescriptions[0].binding = 0;
  attributeDescriptions[0].location = 0;
  attributeDescriptions[0].format =
      VK_FORMAT_R32G32B32A32_SFLOAT;  // Is there a way to normalize floats
  attributeDescriptions[0].offset = offsetof(Vertex, x);

  attributeDescriptions[1].binding = 0;
  attributeDescriptions[1].location = 1;
  attributeDescriptions[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
  attributeDescriptions[1].offset = offsetof(Vertex, r);

  // FIXME: Make sure format for byte and shorts are correct
  attributeDescriptions[2].binding = 0;
  attributeDescriptions[2].location = 2;
  attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
  attributeDescriptions[2].offset = offsetof(Vertex, u);

  m_glow_probe_read_debug_vulkan_inputs.attributeDescriptions.insert(
      m_glow_probe_read_debug_vulkan_inputs.attributeDescriptions.end(),
      attributeDescriptions.begin(),
      attributeDescriptions.end());
}

void GlowVulkanRenderer::InitializeGlowProbeDownsampleInputAttributes() {
  auto& shader = m_vulkan_info.shaders[ShaderId::GLOW_PROBE_DOWNSAMPLE];

  VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
  vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
  vertShaderStageInfo.module = shader.GetVertexShader();
  vertShaderStageInfo.pName = "main";

  VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
  fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
  fragShaderStageInfo.module = shader.GetFragmentShader();
  fragShaderStageInfo.pName = "main";

  m_glow_probe_downsample_vulkan_inputs.shaderStages = {vertShaderStageInfo, fragShaderStageInfo};

  // static buffer: this will hold draws for downsampling. Because everything is normalized, we can
  // reuse the same vertices for all downsampling!
  // Note that we can't do a single giant square - otherwise it would "bleed" over the edges.
  // the boundary between cells needs to be preserved.
  VkVertexInputBindingDescription bindingDescription{};
  bindingDescription.binding = 0;
  bindingDescription.stride = sizeof(Vertex);
  bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
  m_glow_probe_downsample_vulkan_inputs.bindingDescriptions.push_back(bindingDescription);

  std::array<VkVertexInputAttributeDescription, 3> attributeDescriptions{};
  attributeDescriptions[0].binding = 0;
  attributeDescriptions[0].location = 0;
  attributeDescriptions[0].format =
      VK_FORMAT_R32G32B32A32_SFLOAT;  // Is there a way to normalize floats
  attributeDescriptions[0].offset = offsetof(Vertex, x);

  m_glow_probe_downsample_vulkan_inputs.attributeDescriptions.insert(
      m_glow_probe_downsample_vulkan_inputs.attributeDescriptions.end(),
      attributeDescriptions.begin(), attributeDescriptions.end());
}

void GlowVulkanRenderer::InitializeGlowDrawInputAttributes() {
  auto& shader = m_vulkan_info.shaders[ShaderId::GLOW_DRAW];

  VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
  vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
  vertShaderStageInfo.module = shader.GetVertexShader();
  vertShaderStageInfo.pName = "main";

  VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
  fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
  fragShaderStageInfo.module = shader.GetFragmentShader();
  fragShaderStageInfo.pName = "main";

  m_glow_draw_vulkan_inputs.shaderStages = {vertShaderStageInfo, fragShaderStageInfo};

  VkVertexInputBindingDescription bindingDescription{};
  bindingDescription.binding = 0;
  bindingDescription.stride = sizeof(Vertex);
  bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
  m_pipeline_config_info.bindingDescriptions.push_back(bindingDescription);

  std::array<VkVertexInputAttributeDescription, 4> attributeDescriptions{};
  attributeDescriptions[0].binding = 0;
  attributeDescriptions[0].location = 0;
  attributeDescriptions[0].format =
      VK_FORMAT_R32G32B32A32_SFLOAT;  // Is there a way to normalize floats
  attributeDescriptions[0].offset = offsetof(Vertex, x);

  attributeDescriptions[1].binding = 0;
  attributeDescriptions[1].location = 1;
  attributeDescriptions[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
  attributeDescriptions[1].offset = offsetof(Vertex, r);

  // FIXME: Make sure format for byte and shorts are correct
  attributeDescriptions[2].binding = 0;
  attributeDescriptions[2].location = 2;
  attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
  attributeDescriptions[2].offset = offsetof(Vertex, u);

  attributeDescriptions[3].binding = 0;
  attributeDescriptions[3].location = 3;
  attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
  attributeDescriptions[3].offset = offsetof(Vertex, uu);
  m_glow_draw_vulkan_inputs.attributeDescriptions.insert(
      m_glow_draw_vulkan_inputs.attributeDescriptions.end(), attributeDescriptions.begin(),
      attributeDescriptions.end());
}

void GlowVulkanRenderer::SwitchToShader(ShaderId shaderId){
  switch (shaderId) {
    case ShaderId::GLOW_PROBE: {
      m_pipeline_config_info.attributeDescriptions =
          m_glow_probe_vulkan_inputs.attributeDescriptions;
      m_pipeline_config_info.bindingDescriptions =
          m_glow_probe_vulkan_inputs.bindingDescriptions;
      m_pipeline_config_info.shaderStages =
          m_glow_probe_vulkan_inputs.shaderStages;
      break;
    }
    case ShaderId::GLOW_PROBE_READ: {
      m_pipeline_config_info.attributeDescriptions =
          m_glow_probe_read_vulkan_inputs.attributeDescriptions;
      m_pipeline_config_info.bindingDescriptions = m_glow_probe_read_vulkan_inputs.bindingDescriptions;
      m_pipeline_config_info.shaderStages = m_glow_probe_read_vulkan_inputs.shaderStages;
      break;
    }
    case ShaderId::GLOW_PROBE_READ_DEBUG: {
      m_pipeline_config_info.attributeDescriptions =
          m_glow_probe_read_debug_vulkan_inputs.attributeDescriptions;
      m_pipeline_config_info.bindingDescriptions =
          m_glow_probe_read_debug_vulkan_inputs.bindingDescriptions;
      m_pipeline_config_info.shaderStages = m_glow_probe_read_debug_vulkan_inputs.shaderStages;
      break;
    }
    case ShaderId::GLOW_PROBE_DOWNSAMPLE: {
      m_pipeline_config_info.attributeDescriptions =
          m_glow_probe_downsample_vulkan_inputs.attributeDescriptions;
      m_pipeline_config_info.bindingDescriptions =
          m_glow_probe_downsample_vulkan_inputs.bindingDescriptions;
      m_pipeline_config_info.shaderStages = m_glow_probe_downsample_vulkan_inputs.shaderStages;
      break;
    }
    case ShaderId::GLOW_DRAW: {
      m_pipeline_config_info.attributeDescriptions =
          m_glow_draw_vulkan_inputs.attributeDescriptions;
      m_pipeline_config_info.bindingDescriptions =
          m_glow_draw_vulkan_inputs.bindingDescriptions;
      m_pipeline_config_info.shaderStages = m_glow_draw_vulkan_inputs.shaderStages;
      break;
    }
    default: {
    }
  }
}

/*!
 * Blit the depth buffer from the default rendering buffer to the depth buffer of the probe fbo.
 */
void GlowVulkanRenderer::blit_depth(BaseSharedRenderState* render_state) {
  if (m_ogl.probe_fbo_w != render_state->render_fb_w ||
      m_ogl.probe_fbo_h != render_state->render_fb_h) {
    m_ogl.probe_fbo_w = render_state->render_fb_w;
    m_ogl.probe_fbo_h = render_state->render_fb_h;

    m_ogl.probe_fbo = std::make_unique<FramebufferVulkanHelper>(
        m_ogl.probe_fbo_w, m_ogl.probe_fbo_h, VK_FORMAT_R8G8B8A8_UNORM, m_device);
  }

  std::array<VkImageBlit, 1> imageBlits{};
  imageBlits[0].srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
  imageBlits[0].srcSubresource.mipLevel = 0;
  imageBlits[0].srcSubresource.baseArrayLayer = 1;
  imageBlits[0].srcSubresource.layerCount = 1;

  imageBlits[0].srcOffsets[0].x = render_state->render_fb_x;
  imageBlits[0].srcOffsets[0].y = render_state->render_fb_y;
  imageBlits[0].srcOffsets[0].z = 0;
  imageBlits[0].srcOffsets[1].x = render_state->render_fb_x + render_state->render_fb_w;
  imageBlits[0].srcOffsets[1].y = render_state->render_fb_y + render_state->render_fb_h;
  imageBlits[0].srcOffsets[1].z = 0;

  imageBlits[0].srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
  imageBlits[0].dstSubresource.mipLevel = 0;
  imageBlits[0].dstSubresource.baseArrayLayer = 1;
  imageBlits[0].dstSubresource.layerCount = 1;

  imageBlits[0].dstOffsets[0].x = 0;
  imageBlits[0].dstOffsets[0].y = 0;
  imageBlits[0].dstOffsets[0].z = 0;
  imageBlits[0].dstOffsets[1].x = m_ogl.probe_fbo_w;
  imageBlits[0].dstOffsets[1].y = m_ogl.probe_fbo_h;
  imageBlits[0].dstOffsets[1].z = 0;

  vkCmdBlitImage(m_vulkan_info.render_command_buffer,
                 render_fb->ColorAttachmentTexture().getImage(),
                 VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
                 m_ogl.probe_fbo->ColorAttachmentTexture().getImage(),
                 VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, imageBlits.size(), imageBlits.data(),
                 VK_FILTER_NEAREST);
}

/*!
 * Do all downsample draws to make 2x2 textures.
 */
void GlowVulkanRenderer::downsample_chain(BaseSharedRenderState* render_state,
                                    ScopedProfilerNode& prof,
                                    u32 num_sprites) {

  VkPipelineInputAssemblyStateCreateInfo& inputAssembly = m_pipeline_config_info.inputAssemblyInfo;
  inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
  inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
  inputAssembly.primitiveRestartEnable = VK_TRUE;

  SwitchToShader(ShaderId::GLOW_PROBE_DOWNSAMPLE);
  for (int i = 0; i < kDownsampleIterations - 1; i++) {
    auto& source = m_ogl.downsample_fbos[i];
    auto& sampler_create_info = source.sampler->GetSamplerCreateInfo();

    sampler_create_info.minFilter = VK_FILTER_LINEAR;
    sampler_create_info.magFilter = VK_FILTER_LINEAR;

    sampler_create_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    sampler_create_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;

    source.sampler->CreateSampler();

    prof.add_draw_call();
    prof.add_tri(num_sprites * 4);
    // the grid fill order is the same as the downsample order, so we don't need to do all cells
    // if we aren't using all sprites.
    //glDrawElements(GL_TRIANGLE_STRIP, num_sprites * 5, GL_UNSIGNED_INT, nullptr);
    vkCmdDrawIndexed(m_vulkan_info.render_command_buffer, num_sprites * 5, 1, 0, 0, 0);
  }
}

/*!
 * Draw probes (including the clear) to the probe fbo. Also copies vertex/index buffer.
 */
void GlowVulkanRenderer::draw_probes(BaseSharedRenderState* render_state,
                                     ScopedProfilerNode& prof,
                                     u32 idx_start,
                                     u32 idx_end) {
  // glBindFramebuffer(GL_FRAMEBUFFER, m_ogl.probe_fbo);

  vkCmdEndRenderPass(m_vulkan_info.render_command_buffer);
  m_ogl.probe_fbo->beginRenderPass(m_vulkan_info.render_command_buffer);

  m_ogl.vertex_buffer->writeToGpuBuffer(m_vertex_buffer.data(), m_next_vertex * sizeof(Vertex));
  m_ogl.index_buffer->writeToGpuBuffer(m_index_buffer.data(), m_next_index * sizeof(u32));

  VkDeviceSize offsets[] = {0};
  VkBuffer vertex_buffers[] = {m_ogl.vertex_buffer->getBuffer()};
  vkCmdBindVertexBuffers(m_vulkan_info.render_command_buffer, 0, 1, vertex_buffers, offsets);
  vkCmdBindIndexBuffer(m_vulkan_info.render_command_buffer, m_ogl.index_buffer->getBuffer(), 0, VK_INDEX_TYPE_UINT32);

  // do probes
  SwitchToShader(ShaderId::GLOW_PROBE);

  prof.add_draw_call();
  prof.add_tri(m_next_sprite * 4);
  
  m_pipeline_config_info.colorBlendAttachment.blendEnable = VK_FALSE;
  m_pipeline_config_info.depthStencilInfo.depthTestEnable = VK_TRUE;
  m_pipeline_config_info.depthStencilInfo.depthCompareOp = VK_COMPARE_OP_GREATER_OR_EQUAL;

  m_pipeline_layout.createGraphicsPipeline(m_pipeline_config_info);
  m_pipeline_layout.bind(m_vulkan_info.render_command_buffer);

  //glDrawElements(GL_TRIANGLE_STRIP, idx_end - idx_start, GL_UNSIGNED_INT,
  //               (void*)(idx_start * sizeof(u32)));
  vkCmdDrawIndexed(m_vulkan_info.render_command_buffer, idx_end - idx_start, 1, idx_start, 0, 0);
  vkCmdEndRenderPass(m_vulkan_info.render_command_buffer);

  m_vulkan_info.swap_chain->beginSwapChainRenderPass(m_vulkan_info.render_command_buffer,
                                                     m_vulkan_info.currentFrame);
}

/*!
 * Draw red/green probes to the framebuffer for debugging.
 */
void GlowVulkanRenderer::debug_draw_probes(BaseSharedRenderState* render_state,
                                     ScopedProfilerNode& prof,
                                     u32 idx_start,
                                     u32 idx_end) {
  SwitchToShader(ShaderId::GLOW_PROBE_READ_DEBUG);

  prof.add_draw_call();
  prof.add_tri(m_next_sprite * 4);
  //glBindFramebuffer(GL_FRAMEBUFFER, render_state->render_fb);
  //glDrawElements(GL_TRIANGLE_STRIP, idx_end - idx_start, GL_UNSIGNED_INT,
  //               (void*)(idx_start * sizeof(u32)));
  vkCmdDrawIndexed(m_vulkan_info.render_command_buffer, idx_end - idx_start, 1, idx_start, 0, 0);
}

/*!
 * Copy probes from probe fbo to grid.
 */
void GlowVulkanRenderer::draw_probe_copies(BaseSharedRenderState* render_state,
                                     ScopedProfilerNode& prof,
                                     u32 idx_start,
                                     u32 idx_end) {
  // read probe from probe fbo, write it to the first downsample fbo
  SwitchToShader(ShaderId::GLOW_PROBE_READ);
  auto& sampler_create_info = m_ogl.downsample_fbos[0].sampler->GetSamplerCreateInfo();

  sampler_create_info.minFilter = VK_FILTER_LINEAR;
  sampler_create_info.magFilter = VK_FILTER_LINEAR;

  sampler_create_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  sampler_create_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;

  m_ogl.downsample_fbos[0].sampler->CreateSampler();

  prof.add_draw_call();
  prof.add_tri(m_next_sprite * 2);
  //glDrawElements(GL_TRIANGLE_STRIP, idx_end - idx_start, GL_UNSIGNED_INT,
  //               (void*)(idx_start * sizeof(u32)));
  vkCmdDrawIndexed(m_vulkan_info.render_command_buffer, idx_end - idx_start, 1, idx_start, 0, 0);
}

/*!
 * Draw blue squares to show where probes and being copied from, to help debug texture offsets.
 */
void GlowVulkanRenderer::debug_draw_probe_copies(BaseSharedRenderState* render_state,
                                           ScopedProfilerNode& prof,
                                           u32 idx_start,
                                           u32 idx_end) {
  SwitchToShader(ShaderId::GLOW_PROBE_READ_DEBUG);
  prof.add_draw_call();
  prof.add_tri(m_next_sprite * 2);
  //glBindFramebuffer(GL_FRAMEBUFFER, render_state->render_fb);
  //glDrawElements(GL_TRIANGLE_STRIP, idx_end - idx_start, GL_UNSIGNED_INT,
  //               (void*)(idx_start * sizeof(u32)));
  vkCmdDrawIndexed(m_vulkan_info.render_command_buffer, idx_end - idx_start, 1, idx_start, 0, 0);
}

/*!
 * Final drawing of sprites.
 */
void GlowVulkanRenderer::draw_sprites(BaseSharedRenderState* render_state, ScopedProfilerNode& prof) {
  VkPipelineInputAssemblyStateCreateInfo& inputAssembly = m_pipeline_config_info.inputAssemblyInfo;
  inputAssembly.primitiveRestartEnable = VK_TRUE;

  SwitchToShader(ShaderId::GLOW_DRAW);

  auto& sampler_create_info = m_ogl.downsample_fbos[kDownsampleIterations - 1].sampler->GetSamplerCreateInfo();

  sampler_create_info.minFilter = VK_FILTER_LINEAR;
  sampler_create_info.magFilter = VK_FILTER_LINEAR;

  sampler_create_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  sampler_create_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;

  m_pipeline_config_info.depthStencilInfo.depthTestEnable = VK_TRUE;
  m_pipeline_config_info.depthStencilInfo.depthBoundsTestEnable = VK_FALSE;
  m_pipeline_config_info.depthStencilInfo.stencilTestEnable = VK_FALSE;
  m_pipeline_config_info.depthStencilInfo.depthCompareOp = VK_COMPARE_OP_EQUAL;
  m_pipeline_config_info.depthStencilInfo.depthWriteEnable = VK_FALSE;

  m_pipeline_config_info.colorBlendAttachment.blendEnable = VK_TRUE;

  m_pipeline_config_info.colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;  // Optional
  m_pipeline_config_info.colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;  // Optional

  m_pipeline_config_info.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
  m_pipeline_config_info.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;

  m_pipeline_config_info.colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
  m_pipeline_config_info.colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;

  vkCmdPushConstants(m_vulkan_info.render_command_buffer, m_pipeline_config_info.pipelineLayout,
                   VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(float),
                   (void*)&m_debug.glow_boost);

  for (u32 i = 0; i < m_next_sprite; i++) {
    const auto& record = m_sprite_records[i];
    auto tex = m_vulkan_info.texture_pool->lookup_vulkan_texture(record.tbp);
    if (!tex) {
      lg::warn("Failed to find texture at {}, using random (glow)", record.tbp);
      tex = m_vulkan_info.texture_pool->get_placeholder_vulkan_texture();
    }

    if (record.draw_mode.get_clamp_s_enable()) {
      sampler_create_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    } else {
      sampler_create_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    }

    if (record.draw_mode.get_clamp_t_enable()) {
      sampler_create_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    } else {
      sampler_create_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    }

    if (record.draw_mode.get_filt_enable()) {
      sampler_create_info.minFilter = VK_FILTER_LINEAR;
      sampler_create_info.magFilter = VK_FILTER_LINEAR;
    } else {
      sampler_create_info.minFilter = VK_FILTER_NEAREST;
      sampler_create_info.magFilter = VK_FILTER_NEAREST;
    }

    m_ogl.downsample_fbos[kDownsampleIterations - 1].sampler->CreateSampler();

    prof.add_draw_call();
    prof.add_tri(2);
    //glDrawElements(GL_TRIANGLE_STRIP, 5, GL_UNSIGNED_INT, (void*)(record.idx * sizeof(u32)));
    vkCmdDrawIndexed(m_vulkan_info.render_command_buffer, 5, 1, record.idx, 0, 0);
  }
}
